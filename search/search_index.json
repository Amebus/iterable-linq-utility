{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>The library and the documentation are in WIP status</p> <p> </p> <p>A .NET Linq to Objects porting with javacript naming conventions (e.g.: <code>Select</code> as been ranamed to <code>map</code>) and some new features (e.g.: memoize and materialize).</p>"},{"location":"#main-idea","title":"Main Idea","text":"<p>As the previous description says, the idea is to create a kind-of-porting of .NET Linq to Objects with a naming convetions that is more javascript and functional programming oriented and not sql oriented 1. In other words the idea is:</p> <ul> <li>to keep the LINQ Deferred Exceution and apply it to the JavaScript Iterator Protocol with a more standard way of naming well known high order functions like <code>map</code>, <code>flatMap</code>, <code>reduce</code> used by javascript and some functional programming libraries (e.g.: Ramdajs, SanctuaryJs, FantasyLand and lodash). </li> <li>to keep the Linq repeatable execution which allows to traverse the same chain multiple times without having to recreate it from scratch every time, in this way is possible to store the chain in a variable and then trigger it to get the max and min without recreating it:   Repeatable execution<pre><code>const myChain = IterableLinq.from([1,2,3,4]).filter().map(); // chain creation\nconst max = myChain.max();\nconst min = myChain.min(); // using the same chain twice\n</code></pre></li> </ul> <p>Since in javascript you cannot rely on extensions methods as in c# there is the need to create a wrapper over <code>Iterable</code> to achive the same Deferred Exceution concept. To help document the package we also take a cue from some definitions used by Apache Spark, since, in fact, the wrapper created is similar to Apache Spark's RDDs. Hence we are going to name a code like the following:</p> Operations Chain example<pre><code>IterableLinq\n.fromRange(start, end)\n.filter(myFilterFunction)\n.map(myMapFunction)\n.collectToArray()\n</code></pre> <p>as Operations Chain or OsC. The OsC supports two types of operations:</p> <ul> <li>Actions</li> <li>Transformations</li> </ul> <p>like Spark RDD Operations</p> <p>Note</p> <p>There is no multi node implementation running into <code>iterable-linq-utility</code> package, evertything is done on the same machine and is single thread. From Apache Spark comes only some definitons and ideas to help to document the package itself.</p> <p>So let's get started</p> <ol> <li> <p>What is the reasoning behind naming of the .NETs Select (Map) and Aggregate (Reduce)? \u21a9</p> </li> </ol>"},{"location":"alternative-projects/","title":"Alternative Projects","text":""},{"location":"alternative-projects/#objects-and-iterable-manipulation","title":"Objects and iterable manipulation","text":"<ul> <li>Lodash official docs at lodash.com</li> <li>Ramda official docs at ramdajs.com</li> </ul>"},{"location":"alternative-projects/#linq-porting","title":"Linq porting","text":"<ul> <li>linq-es2015</li> <li>Linq-Collections</li> <li>linqts</li> <li>node-enumerable</li> <li>LINQ To TypeScript</li> </ul>"},{"location":"basic-concepts/","title":"Basic Concepts","text":""},{"location":"basic-concepts/#actions-vs-transformations","title":"Actions vs Transformations","text":"<p>TLDR</p> Operations Returned Type Behaviour Actions Primitive Type or Object Triggers the OsC on which is executed. The operation requested by the action is immediatly run. Transformations <code>ILinqIterable</code> Adds a data manipulation operation to the OsC on which it is executed. The operation requested by the trasformation will only be run if an action is requested over the operations chain <p>Quote</p> <p>Transformations create RDDs from each other, but when we want to work with the actual dataset, at that point action is performed. When the action is triggered after the result, new RDD is not formed like transformation. Thus, Actions are Spark RDD operations that give non-RDD values. The values of action are stored to drivers or to the external storage system. It brings laziness of RDD into motion. 1</p> <p>With the same idea of Apache Spark in mind, there are two main kind of operations provided by the <code>Linq Iterable Utility</code> package:</p> <ul> <li>Actions</li> <li>Transformations</li> </ul>"},{"location":"basic-concepts/#actions","title":"Actions","text":"<p>Actions can be seen as ending operations because they will cause the operations chain to be computed and will return the result of the computation. The simplest Action that can come in mind is the <code>collectToArray</code>, which returns an array with all the items returned by the operations chain. Other famous Actions are: <code>some</code>, <code>reduce</code>, <code>max</code> and <code>min</code> to name some of them. The full list of Actions provided by <code>Linq ITerable Utility</code> can be found here.  </p> <p>Info</p> <p>There is one exception to the Actions Definition. The materialize is an Actions even if it returns an <code>ILinqIterable</code>, the reason is that we need to keep alive the iterable wrapper provided by the <code>linq-iterable-utility</code> (since in javascript you cannot rely on extensions methods as in c#) so that is possible to continue with the data manipulation. More in-depth about this topic can be found here.</p>"},{"location":"basic-concepts/#transformations","title":"Transformations","text":"<p>On the other hand, Transformations are operations that compose the OsC and consists of a list of data manipulation operation. The simplest and most known Transformation is certainly the <code>map</code>, which is generally use to change the shape of every item of a list. Other famous Transformations are: <code>filter</code> and <code>flatMap</code> to name some of them. The full list of Transformations provided by <code>Linq ITerable Utility</code> can be found here.  </p>"},{"location":"basic-concepts/#deferred-execution","title":"Deferred Execution","text":"<ol> <li> <p>Spark RDD Operations-Transformation &amp; Action with Example \u21a9</p> </li> </ol>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#npm","title":"Npm","text":"<pre><code>npm install iterable-linq-utility\n</code></pre>"},{"location":"getting-started/#yarn","title":"Yarn","text":"<pre><code>yarn add iterable-linq-utility\n</code></pre>"},{"location":"getting-started/#pnpm","title":"Pnpm","text":"<pre><code>pnpm i iterable-linq-utility\n</code></pre>"},{"location":"getting-started/#cdn","title":"CDN","text":""},{"location":"getting-started/#jsdelivr","title":"JsDelivr","text":"<pre><code>&lt;!-- TODO: check that it works --&gt;\n&lt;script src=\"https://cdn.jsdelivr.net/npm/iterable-linq-utility\"&gt;&lt;/script&gt;\n</code></pre>"},{"location":"getting-started/#unpkg","title":"Unpkg","text":"<pre><code>&lt;!-- TODO: check that it works --&gt;\n&lt;script src=\"https://unpkg.com/ag-grid-community/dist/interable-linq-utility.js\"&gt;&lt;/script&gt;\n</code></pre>"},{"location":"getting-started/#usage","title":"Usage","text":"TypescriptJavascript <pre><code>// recommended\nimport * as IterableLinq from 'iterable-linq-utility'\nIterableLinq.from([1,2,3,4]).map(v =&gt; v * 10).collectToArray();\n// or\nimport { from } from 'iterable-linq-utility';\nfrom([1,2,3,4]).map(v =&gt; v * 10).collectToArray();\n</code></pre> <p>TODO</p>"},{"location":"getting-started/#where-to-go-from-here","title":"Where to go from here","text":"<ol> <li>Be sure to check the Basic Concepts</li> <li>Go to Advanced Concepts to check about advanced usage scenarios and features provided by the utility</li> <li>Check the Glossary to get more indepth about the utility and meanings of the most important words used by this documentation</li> <li>Check how you can integrate the utility with other libraries</li> <li>Compare this library with other similar libraries</li> </ol>"},{"location":"glossary/","title":"Glossary","text":""},{"location":"glossary/#action","title":"Action","text":"<p>An Action is an operation that cause to OsC to be materialized. In other words, an Action is what causes triggers data manipulation to achieve the result described through the OsC.</p>"},{"location":"glossary/#deferred-execution","title":"Deferred Execution","text":""},{"location":"glossary/#eager-evaluation","title":"Eager Evaluation","text":""},{"location":"glossary/#fully-deferred-execution","title":"Fully Deferred Execution","text":""},{"location":"glossary/#immediate-evaluation","title":"Immediate Evaluation","text":""},{"location":"glossary/#lazy-evaluation","title":"Lazy Evaluation","text":""},{"location":"glossary/#operations-chain","title":"Operations Chain","text":"<p>The list of <code>data manipulation operations</code> generated over an <code>Iterable</code>.</p>"},{"location":"glossary/#osc","title":"OsC","text":"<p>The acronym for Operations Chain</p>"},{"location":"glossary/#partially-deferred-execution","title":"Partially Deferred Execution","text":""},{"location":"glossary/#repeatable-execution","title":"Repeatable Execution","text":""},{"location":"glossary/#transformation","title":"Transformation","text":""},{"location":"how-to-contribute/","title":"How to contribute","text":"<p>WIP</p>"},{"location":"advanced-concepts/","title":"Advanced Concepts","text":""},{"location":"advanced-concepts/#deferred-execution","title":"Deferred Execution","text":""},{"location":"advanced-concepts/#input-iterable-mutability","title":"Input iterable mutability","text":""},{"location":"advanced-concepts/#fully-deffered-execution","title":"Fully Deffered Execution","text":""},{"location":"advanced-concepts/#partially-deffered-execution","title":"Partially Deffered Execution","text":""},{"location":"advanced-concepts/#eager-evaluation","title":"Eager Evaluation","text":""},{"location":"advanced-concepts/#repeatable-execution","title":"Repeatable Execution","text":""},{"location":"advanced-concepts/#repeatable-execution-caveats","title":"Repeatable Execution Caveats","text":""},{"location":"advanced-concepts/#memoize-in-depth","title":"Memoize in-depth","text":""},{"location":"advanced-concepts/#materialize-in-depth","title":"Materialize in-depth","text":""},{"location":"advanced-concepts/#memoize-vs-materialize","title":"Memoize vs Materialize","text":""},{"location":"api-reference/","title":"Api","text":""},{"location":"api-reference/actions/","title":"Actions","text":"<p>An Action is an operation that cause to OsC to be materialized. In other words, an Action is what causes triggers data manipulation to achieve the result described through the OsC.</p> TLDR list of Actions Action Brief Description collectToArray Collect the data of the input <code>Iterable</code> into an <code>Array</code> forEach Performs the specified action on each element of the input <code>Iterable</code> forEachAsync Performs the specified async action on each element of the input<code>Iterable</code> max Returns the maximum value found in the input <code>Iterable</code> min Returns the minimum value found in the input <code>Iterable</code> reduce Accumulates all the elements of input <code>Iterable</code> into a single result and returns it"},{"location":"api-reference/actions/#collecttoarray","title":"collectToArray","text":"<p>Collect the data of the input <code>Iterable</code> into an <code>Array</code>.</p> WrapperRaw Function <pre><code>import * as IterableLinq from 'iterable-linq-utility'\nIterableLinq\n.from([1,2,3,4])\n.collectToArray();\n// [1,2,3,4]\n</code></pre> <pre><code>import { Functions } from 'iterable-linq-utility';\nFunctions.collectToArray([1,2,3,4]);\n// [1,2,3,4]\n</code></pre>"},{"location":"api-reference/actions/#foreach","title":"forEach","text":"<p>Performs the specified action on each element of the <code>Iterable&lt;T&gt;</code>.</p> WrapperRaw Function <pre><code>import * as IterableLinq from 'iterable-linq-utility'\nIterableLinq\n.from([1,2,3,4])\n.forEach(v =&gt; {\nconsole.log(v);\nreturn unit();\n});\n// 1\n// 2\n// 3\n// 4\n</code></pre> <pre><code>import { Functions } from 'iterable-linq-utility';\nFunctions.forEach([1,2,3,4], v =&gt; {\nconsole.log(v)\nreturn unit();\n});\n// 1\n// 2\n// 3\n// 4\n</code></pre>"},{"location":"api-reference/actions/#foreachasync","title":"forEachAsync","text":"<p>Performs the specified async action on each element of the <code>Iterable&lt;T&gt;</code>. The <code>forEachAsync</code> will wait until all the promeses are either resolved or rejected, but it will not wait the action running on the current item to complete before running the action on the next item.</p> WrapperRaw Function <pre><code>import * as IterableLinq from 'iterable-linq-utility'\nIterableLinq\n.from([1,2,3,4])\n.forEach(async v =&gt; {\nreturn new Promise&lt;IterableLinq.Unit&gt;(resolve =&gt; {\nconsole.log(v);\nresolve(IterableLinq.unit());\n});\n});\n// 1\n// 2\n// 3\n// 4\n</code></pre> <pre><code>import { Functions, Unit, unit } from 'iterable-linq-utility';\nFunctions.forEach([1,2,3,4], async v =&gt; {\nreturn new Promise&lt;Unit&gt;(resolve =&gt; {\nconsole.log(v);\nresolve(unit());\n});\n});\n// 1\n// 2\n// 3\n// 4\n</code></pre>"},{"location":"api-reference/actions/#max","title":"max","text":"<p>Returns the maximum value found in the input <code>Iterable</code></p> WrapperRaw Function <pre><code>import * as IterableLinq from 'iterable-linq-utility'\nIterableLinq\n.from([1,2,3,4])\n.max();\n// 4\n</code></pre> <pre><code>import { Functions } from 'iterable-linq-utility';\nFunctions.max([1,2,3,4]);\n// 4\n</code></pre> <p>It is possible to specify a custom comparer option:</p> <ol> <li> <p>The name or a list of names of the property to use to identify the maximum value of the <code>Iterable</code></p> WrapperRaw Function <pre><code>import * as IterableLinq from 'iterable-linq-utility'\nIterableLinq\n.from([{ value: 1 },{ value: 2 },{ value: 3 },{ value: 4 }])\n.max('value');\n// 4\n</code></pre> <pre><code>import { Functions } from 'iterable-linq-utility';\nFunctions.max([{ value: 1 },{ value: 2 },{ value: 3 },{ value: 4 }], 'value');\n// 3\n</code></pre> </li> <li> <p>A function like <code>(a: T, b: T) =&gt; number</code> which accepts two elements of the <code>Iterable</code> and returns a number as follow:</p> <ul> <li>-1 if <code>a</code> is lesser than <code>b</code></li> <li>0 if <code>a</code> is equal to <code>b</code></li> <li>1 if <code>a</code> is greather then <code>b</code></li> </ul> WrapperRaw Function <pre><code>import * as IterableLinq from 'iterable-linq-utility'\nIterableLinq\n.from([1,2,3,4])\n.max( (a, b) =&gt; a === 3 ? 1 : -1 );\n// 3\n</code></pre> <pre><code>import { Functions } from 'iterable-linq-utility';\nFunctions.max([1,2,3,4], (a, b) =&gt; a === 3 ? 1 : -1);\n// 3\n</code></pre> </li> </ol>"},{"location":"api-reference/actions/#min","title":"min","text":"<p>Returns the minimum value found in the input <code>Iterable</code></p> WrapperRaw Function <pre><code>import * as IterableLinq from 'iterable-linq-utility'\nIterableLinq\n.from([1,2,3,4])\n.min();\n// 1\n</code></pre> <pre><code>import { Functions } from 'iterable-linq-utility';\nFunctions.min([1,2,3,4]);\n// 1\n</code></pre> <p>It is possible to specify a custom comparer option:</p> <ol> <li> <p>The name or a list of names of the property to use to identify the maximum value of the <code>Iterable</code></p> WrapperRaw Function <pre><code>import * as IterableLinq from 'iterable-linq-utility'\nIterableLinq\n.from([{ value: 1 },{ value: 2 },{ value: 3 },{ value: 4 }])\n.min( 'value' );\n// 1\n</code></pre> <pre><code>import { Functions } from 'iterable-linq-utility';\nFunctions.min([{ value: 1 },{ value: 2 },{ value: 3 },{ value: 4 }], 'value');\n// 1\n</code></pre> </li> <li> <p>A function like <code>(a: T, b: T) =&gt; number</code> which accepts two elements of the <code>Iterable</code> and returns a number as follow:</p> <ul> <li>-1 if <code>a</code> is lesser than <code>b</code></li> <li>0 if <code>a</code> is equal to <code>b</code></li> <li>1 if <code>a</code> is greather then <code>b</code></li> </ul> WrapperRaw Function <pre><code>import * as IterableLinq from 'iterable-linq-utility'\nIterableLinq\n.from([1,2,3,4])\n.min( (a, b) =&gt; a === 1 ? 1 : -1 );\n// 2\n</code></pre> <pre><code>import { Functions } from 'iterable-linq-utility';\nFunctions.min([1,2,3,4], (a, b) =&gt; a === 1 ? 1 : -1);\n// 2\n</code></pre> </li> </ol>"},{"location":"api-reference/actions/#reduce","title":"reduce","text":""},{"location":"api-reference/transformations/","title":"Transformations","text":"TLDR list of Transformations <ul> <li> Is start of a new chain</li> <li> Immediate Execution</li> <li> Partially Deferred Execution</li> <li> Fully Deferred Execution</li> <li> Eager Evaluation</li> <li> Available in the <code>ILinqIterable</code> wrapper</li> <li> Available as raw function</li> </ul> Transformation Brief Description empty Returns an empty <code>Iterable</code> filter Returns a new iterable flatMap from fromRange Returns an <code>Iterable</code> of numbers (positive and/or negative) progressing from start up to, but not including, end. map memoize materialize Triggers the operations chain and store it in a new <code>Iterable</code>. It returns an <code>ILinqIterable</code> to allow to create a brand new operations chain. Helpful to boost performance. repeat Returns an <code>Iterable</code> which will repeats the given value n times. tap tapChain tapChainCreation"},{"location":"api-reference/transformations/#empty","title":"empty","text":"WrapperRaw Function <pre><code>import * as IterableLinq from 'iterable-linq-utility'\nIterableLinq\n.empty()\n.collectToArray();\n// []\n</code></pre> <pre><code>import { Functions } from 'iterable-linq-utility';\nArray.from(Functions.empty());\n// []\n</code></pre>"},{"location":"api-reference/transformations/#filter","title":"filter","text":"WrapperRaw Function <pre><code>import * as IterableLinq from 'iterable-linq-utility'\nIterableLinq\n.from([1,2,3,4])\n.filter( v =&gt; v % 2 === 0)\n.collectToArray();\n// [2,4]\n</code></pre> <pre><code>import { Functions } from 'iterable-linq-utility';\nArray.from(Functions.filter([1,2,3,4], v =&gt; v % 2 === 0));\n// [2,4]\n</code></pre>"},{"location":"api-reference/transformations/#flatmap","title":"flatMap","text":""},{"location":"api-reference/transformations/#from","title":"from","text":""},{"location":"api-reference/transformations/#fromrange","title":"fromRange","text":""},{"location":"api-reference/transformations/#map","title":"map","text":"WrapperRaw Function <pre><code>import * as IterableLinq from 'iterable-linq-utility'\nIterableLinq\n.from([1,2,3,4])\n.map( v =&gt; v * 10 )\n.collectToArray();\n// [10,20,30,40]\n</code></pre> <pre><code>import { Functions } from 'iterable-linq-utility';\nArray.from(Functions.map([1,2,3,4], v =&gt; v * 10));\n// [10,20,30,40]\n</code></pre>"},{"location":"api-reference/transformations/#memoize","title":"memoize","text":""},{"location":"api-reference/transformations/#materialize","title":"materialize","text":"WrapperRaw Function <pre><code>import * as IterableLinq from 'iterable-linq-utility'\nIterableLinq\n.from([1,2,3,4])\n.materilize()\n.collectToArray();\n// [1,2,3,4]\n</code></pre> <pre><code>import { Functions } from 'iterable-linq-utility';\nArray.from(Functions.materialize([1,2,3,4]));\n// [1,2,3,4]\n</code></pre>"},{"location":"api-reference/transformations/#repeat","title":"repeat","text":"WrapperRaw Function <pre><code>import * as IterableLinq from 'iterable-linq-utility'\nIterableLinq\n.repeat(5,3)\n.collectToArray();\n// [5,5,5]\n</code></pre> <pre><code>import { Functions } from 'iterable-linq-utility';\nArray.from(Functions.repeat(5, 3));\n// [5,5,5]\n</code></pre>"},{"location":"api-reference/transformations/#tap","title":"tap","text":""},{"location":"api-reference/transformations/#tapchain","title":"tapChain","text":""},{"location":"api-reference/transformations/#tapchaincreation","title":"tapChainCreation","text":""}]}